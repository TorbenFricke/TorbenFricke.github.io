{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"An easy-to-use Python UI Framework on top of Qt (PySide6). Simple things are simple, hard things are not any harder than they are in Qt. Features Cross Platform: Tested on Windows and macOS Low Boilerplate: Save, load and autosave functionality out of the box A unified API to set and retrieve data in UI elements Layout using tabs, segments, a sidebar and a grid system Row , Col Singe instance enforcement Installation UI based on PyInstaller (Windows only) Install Install formify using PyPi: pip install formify First App Write your first App featuring a text area with save, load, and autosave functionality. from formify import * ui = ControlTextarea ( \"Write Here\" , variable_name = \"text\" ) MainWindow ( ui , title = \"First App\" , margin = 8 ) Windows macOS More Examples Check out the Gallery for more examples.","title":"Overview"},{"location":"#features","text":"Cross Platform: Tested on Windows and macOS Low Boilerplate: Save, load and autosave functionality out of the box A unified API to set and retrieve data in UI elements Layout using tabs, segments, a sidebar and a grid system Row , Col Singe instance enforcement Installation UI based on PyInstaller (Windows only)","title":"Features"},{"location":"#install","text":"Install formify using PyPi: pip install formify","title":"Install"},{"location":"#first-app","text":"Write your first App featuring a text area with save, load, and autosave functionality. from formify import * ui = ControlTextarea ( \"Write Here\" , variable_name = \"text\" ) MainWindow ( ui , title = \"First App\" , margin = 8 ) Windows macOS","title":"First App"},{"location":"#more-examples","text":"Check out the Gallery for more examples.","title":"More Examples"},{"location":"controls/","text":"Bases: ControlBase A textfield","title":"Controls"},{"location":"data_modeling/","text":"A key design decision when creating formify was the mixing of the UI with the data model. This allows for advanced functionality like autosave/autoload out of the box. However, it comes at the cost of flexibility. This section covers how data can be modeled using formify. Nested Values This example shows a nested Form containing basic contact_info . The nested form can be placed inside a parent form and its data is placed into a sub-dict with the variable name given to the child form. If you were to remove the variable_name of the contact_info Form, no sub-dict would be created. Code Data Screenshot import json from formify import * contact_info = Form ( Col ( ControlText ( \"Phone Number\" , variable_name = \"phone\" ), ControlText ( \"Email Address\" , variable_name = \"email\" ), ), variable_name = \"contact_info\" ) main_from = Form ( Col ( Row ( ControlText ( \"First Name\" , variable_name = \"first_name\" ), ControlText ( \"Surname\" , variable_name = \"surname\" ), ), ControlInt ( \"Age\" , variable_name = \"age\" ), contact_info , ControlButton ( \"Print Value\" , on_click = lambda : print ( json . dumps ( main_from . value , indent = 2 )) ), )) MainWindow ( main_from , margin = 9 , title = \"Nested Values\" ) main_form.value gives: { \"first_name\" : \"Nicola\" , \"surname\" : \"Hailee\" , \"age\" : 32 , \"contact_info\" : { \"phone\" : \"+1 544 554 335\" , \"email\" : \"n.hailee@domain.xyz\" } } Flatten Nested Values __flatten__ is a special variable name, that includes the fields in a form into the parent form. If we were to replace the variable_name in the contact form.... contact_info = Form ( Col ( ControlText ( \"Phone Number\" , variable_name = \"phone\" ), ControlText ( \"Email Address\" , variable_name = \"email\" ), ), variable_name = \"__flatten__\" ) ... the resulting data model would look like this: { \"first_name\" : \"Nicola\" , \"surname\" : \"Hailee\" , \"age\" : 32 , \"phone\" : \"+1 544 554 335\" , \"email\" : \"n.hailee@domain.xyz\" } Lists A ListForm can be used to model fields that can have multiple entries. Building from the example above, we can add an arbitrary number of contact information sets. Code Data Screenshot import json from formify import * contact_info = Form ( Col ( ControlText ( \"Kind\" , variable_name = \"contact_kind\" ), ControlText ( \"Phone Number\" , variable_name = \"phone\" ), ControlText ( \"Email Address\" , variable_name = \"email\" ), )) contact_info_list = ListForm ( model_form = contact_info , variable_name = \"contact_info\" , ) main_from = Form ( Col ( Row ( ControlText ( \"First Name\" , variable_name = \"first_name\" ), ControlText ( \"Surname\" , variable_name = \"surname\" ), ), ControlInt ( \"Age\" , variable_name = \"age\" ), contact_info_list , ControlButton ( \"Print Value\" , on_click = lambda : print ( json . dumps ( main_from . value , indent = 2 )) ), )) MainWindow ( main_from , margin = 9 , title = \"Nested Values\" ) main_form.value gives: { \"first_name\" : \"Nicola\" , \"surname\" : \"Hailee\" , \"age\" : 32 , \"contact_info\" : [ { \"contact_kind\" : \"Work\" , \"phone\" : \"+1 544 554 335\" , \"email\" : \"n.hailee@domain.xyz\" }, { \"contact_kind\" : \"Home\" , \"phone\" : \"+1 364 211 571\" , \"email\" : \"n.hailee@super_private.xyz\" } ] } Custom Display Name Define a display_name_callback to provide a custom label for a list entry. contact_info_list = ListForm ( model_form = contact_info , variable_name = \"contact_info\" , display_name_callback = lambda x : x [ \"contact_kind\" ], ) Conditional Data","title":"Data Modelling"},{"location":"data_modeling/#nested-values","text":"This example shows a nested Form containing basic contact_info . The nested form can be placed inside a parent form and its data is placed into a sub-dict with the variable name given to the child form. If you were to remove the variable_name of the contact_info Form, no sub-dict would be created. Code Data Screenshot import json from formify import * contact_info = Form ( Col ( ControlText ( \"Phone Number\" , variable_name = \"phone\" ), ControlText ( \"Email Address\" , variable_name = \"email\" ), ), variable_name = \"contact_info\" ) main_from = Form ( Col ( Row ( ControlText ( \"First Name\" , variable_name = \"first_name\" ), ControlText ( \"Surname\" , variable_name = \"surname\" ), ), ControlInt ( \"Age\" , variable_name = \"age\" ), contact_info , ControlButton ( \"Print Value\" , on_click = lambda : print ( json . dumps ( main_from . value , indent = 2 )) ), )) MainWindow ( main_from , margin = 9 , title = \"Nested Values\" ) main_form.value gives: { \"first_name\" : \"Nicola\" , \"surname\" : \"Hailee\" , \"age\" : 32 , \"contact_info\" : { \"phone\" : \"+1 544 554 335\" , \"email\" : \"n.hailee@domain.xyz\" } }","title":"Nested Values"},{"location":"data_modeling/#flatten-nested-values","text":"__flatten__ is a special variable name, that includes the fields in a form into the parent form. If we were to replace the variable_name in the contact form.... contact_info = Form ( Col ( ControlText ( \"Phone Number\" , variable_name = \"phone\" ), ControlText ( \"Email Address\" , variable_name = \"email\" ), ), variable_name = \"__flatten__\" ) ... the resulting data model would look like this: { \"first_name\" : \"Nicola\" , \"surname\" : \"Hailee\" , \"age\" : 32 , \"phone\" : \"+1 544 554 335\" , \"email\" : \"n.hailee@domain.xyz\" }","title":"Flatten Nested Values"},{"location":"data_modeling/#lists","text":"A ListForm can be used to model fields that can have multiple entries. Building from the example above, we can add an arbitrary number of contact information sets. Code Data Screenshot import json from formify import * contact_info = Form ( Col ( ControlText ( \"Kind\" , variable_name = \"contact_kind\" ), ControlText ( \"Phone Number\" , variable_name = \"phone\" ), ControlText ( \"Email Address\" , variable_name = \"email\" ), )) contact_info_list = ListForm ( model_form = contact_info , variable_name = \"contact_info\" , ) main_from = Form ( Col ( Row ( ControlText ( \"First Name\" , variable_name = \"first_name\" ), ControlText ( \"Surname\" , variable_name = \"surname\" ), ), ControlInt ( \"Age\" , variable_name = \"age\" ), contact_info_list , ControlButton ( \"Print Value\" , on_click = lambda : print ( json . dumps ( main_from . value , indent = 2 )) ), )) MainWindow ( main_from , margin = 9 , title = \"Nested Values\" ) main_form.value gives: { \"first_name\" : \"Nicola\" , \"surname\" : \"Hailee\" , \"age\" : 32 , \"contact_info\" : [ { \"contact_kind\" : \"Work\" , \"phone\" : \"+1 544 554 335\" , \"email\" : \"n.hailee@domain.xyz\" }, { \"contact_kind\" : \"Home\" , \"phone\" : \"+1 364 211 571\" , \"email\" : \"n.hailee@super_private.xyz\" } ] }","title":"Lists"},{"location":"data_modeling/#custom-display-name","text":"Define a display_name_callback to provide a custom label for a list entry. contact_info_list = ListForm ( model_form = contact_info , variable_name = \"contact_info\" , display_name_callback = lambda x : x [ \"contact_kind\" ], )","title":"Custom Display Name"},{"location":"data_modeling/#conditional-data","text":"","title":"Conditional Data"},{"location":"localization/","text":"Localization There are two ways of localizing your code. First, the Translator and a simple language switch . Whichever option you choose, the localization happens on start up. If you change the language, the program has to be restarted. formify.localization Translator By the default, the system language is used (i.e. \"en\", \"de\", \"fr\", ...) language = language instance-attribute Set the current language (usually a language code) add ( id , ** langauges ) Add translations for an id. You can use any string as `id. translator = Translator () translator . add ( \"button_open\" , en = \"Open\" , de = \"\u00d6ffnen\" }) translator . language = \"de\" print ( translator ( \"button_open\" )) # returns \"\u00d6ffnen\" __call__ ( id ) Grab the translation for id based on the current language. Always returns a string. If no translation for the current language translator.language is provided, the id is returned. translator ( \"button_open\" ) load ( file_name ) Reads all translations into a JSON file. save ( file_name ) Dumps all translations into a JSON file. default_translator ( * args , ** kwargs ) Returns a Translator , populated with translations for default menu items (Open, Close, ...) for german and english. args and kwargs are passed to the Translator( args, **kwargs). make_language_switch ( translator , language_order ) Makes a function, that selects the argument corresponding to the current language. Best read the example below: translator = Translator () switch = make_language_switch ( translator , [ \"en\" , \"de\" ]) translator . language = \"en\" print ( switch ( \"open\" , \"\u00f6ffnen\" )) # prints \"open\" translator . language = \"de\" print ( switch ( \"open\" , \"\u00f6ffnen\" )) # prints \"\u00f6ffnen\" # set the text of a button ControlButton ( switch ( \"open\" , \"\u00f6ffnen\" )) Parameters: Name Type Description Default translator Translator used to determine the current language required language_order list language order of the language switch arguments required Returns: Name Type Description language_switch callable language switch function","title":"Localization"},{"location":"localization/#localization","text":"There are two ways of localizing your code. First, the Translator and a simple language switch . Whichever option you choose, the localization happens on start up. If you change the language, the program has to be restarted.","title":"Localization"},{"location":"localization/#formify.localization","text":"","title":"localization"},{"location":"localization/#formify.localization.Translator","text":"By the default, the system language is used (i.e. \"en\", \"de\", \"fr\", ...)","title":"Translator"},{"location":"localization/#formify.localization.Translator.language","text":"Set the current language (usually a language code)","title":"language"},{"location":"localization/#formify.localization.Translator.add","text":"Add translations for an id. You can use any string as `id. translator = Translator () translator . add ( \"button_open\" , en = \"Open\" , de = \"\u00d6ffnen\" }) translator . language = \"de\" print ( translator ( \"button_open\" )) # returns \"\u00d6ffnen\"","title":"add()"},{"location":"localization/#formify.localization.Translator.__call__","text":"Grab the translation for id based on the current language. Always returns a string. If no translation for the current language translator.language is provided, the id is returned. translator ( \"button_open\" )","title":"__call__()"},{"location":"localization/#formify.localization.Translator.load","text":"Reads all translations into a JSON file.","title":"load()"},{"location":"localization/#formify.localization.Translator.save","text":"Dumps all translations into a JSON file.","title":"save()"},{"location":"localization/#formify.localization.default_translator","text":"Returns a Translator , populated with translations for default menu items (Open, Close, ...) for german and english. args and kwargs are passed to the Translator( args, **kwargs).","title":"default_translator()"},{"location":"localization/#formify.localization.make_language_switch","text":"Makes a function, that selects the argument corresponding to the current language. Best read the example below: translator = Translator () switch = make_language_switch ( translator , [ \"en\" , \"de\" ]) translator . language = \"en\" print ( switch ( \"open\" , \"\u00f6ffnen\" )) # prints \"open\" translator . language = \"de\" print ( switch ( \"open\" , \"\u00f6ffnen\" )) # prints \"\u00f6ffnen\" # set the text of a button ControlButton ( switch ( \"open\" , \"\u00f6ffnen\" )) Parameters: Name Type Description Default translator Translator used to determine the current language required language_order list language order of the language switch arguments required Returns: Name Type Description language_switch callable language switch function","title":"make_language_switch()"},{"location":"threading/","text":"Formify implements a few helper functions to move expensive calculations outside the Ui thread: formify.tools.BackgroundMethod Bases: Thread A wrapper to execute a function in a background thread. Usage: import time @formify . tools . BackgroundMethod def expensive_calculation ( text ): time . sleep ( 1 ) print ( text ) expensive_calculation ( \"1\" ) expensive_calculation ( \"2\" ) expensive_calculation ( \"3\" ) print ( \"Hello\" ) # will be printed first Output: Hello 1 2 3 __init__ ( target , lazy = None , cleanup = None ) Parameters: Name Type Description Default target typing . Callable Target method (is executed, when the BackgroundMethod instance is called) required lazy bool A call is skipped, if a newer one is queued. None cleanup typing . Callable Runs after the target, if provided. None Returns: Name Type Description BakgroundMethod typing . Callable A callable thread, that executes the target with Callable. If a cleanup is provided, this runs afterwards. __call__ ( * args , ** kwargs ) Executes the self.target with the provided args and *kwargs. formify.tools.LazyBackgroundMethod Bases: BackgroundMethod Executes only the latest call. Helpful for updating a plot and wherever else you are only interested in the latest result. Usage: import time @formify . tools . LazyBackgroundMethod def expensive_calculation ( text ): time . sleep ( 1 ) print ( text ) expensive_calculation ( \"1\" ) expensive_calculation ( \"2\" ) # will not be executed! expensive_calculation ( \"3\" ) print ( \"Hello\" ) Output: Hello 1 3 formify . tools . do_in_ui_thread ( func ) Immediately executes func in the main thread (UI thread). Useful when interacting with UI elements. Usage: textarea = formify . ControlTextarea ( \"Output\" ) @formify . tools . BackgroundMethod def expensive_calculation ( text ): time . sleep ( 1 ) def output_text (): textarea . value += text + \" \\n \" do_in_ui_thread ( output_text ) expensive_calculation ( 1 ) expensive_calculation ( 2 ) expensive_calculation ( 3 ) The textarea should contain: 1 2 3 Parameters: Name Type Description Default func typing . Callable fucntion to be called (without any arguments) required","title":"Threading"},{"location":"threading/#formify.tools.BackgroundMethod","text":"Bases: Thread A wrapper to execute a function in a background thread. Usage: import time @formify . tools . BackgroundMethod def expensive_calculation ( text ): time . sleep ( 1 ) print ( text ) expensive_calculation ( \"1\" ) expensive_calculation ( \"2\" ) expensive_calculation ( \"3\" ) print ( \"Hello\" ) # will be printed first Output: Hello 1 2 3","title":"BackgroundMethod"},{"location":"threading/#formify.tools.background_method.BackgroundMethod.__init__","text":"Parameters: Name Type Description Default target typing . Callable Target method (is executed, when the BackgroundMethod instance is called) required lazy bool A call is skipped, if a newer one is queued. None cleanup typing . Callable Runs after the target, if provided. None Returns: Name Type Description BakgroundMethod typing . Callable A callable thread, that executes the target with Callable. If a cleanup is provided, this runs afterwards.","title":"__init__()"},{"location":"threading/#formify.tools.background_method.BackgroundMethod.__call__","text":"Executes the self.target with the provided args and *kwargs.","title":"__call__()"},{"location":"threading/#formify.tools.LazyBackgroundMethod","text":"Bases: BackgroundMethod Executes only the latest call. Helpful for updating a plot and wherever else you are only interested in the latest result. Usage: import time @formify . tools . LazyBackgroundMethod def expensive_calculation ( text ): time . sleep ( 1 ) print ( text ) expensive_calculation ( \"1\" ) expensive_calculation ( \"2\" ) # will not be executed! expensive_calculation ( \"3\" ) print ( \"Hello\" ) Output: Hello 1 3","title":"LazyBackgroundMethod"},{"location":"threading/#formify.tools.do_in_ui_thread","text":"Immediately executes func in the main thread (UI thread). Useful when interacting with UI elements. Usage: textarea = formify . ControlTextarea ( \"Output\" ) @formify . tools . BackgroundMethod def expensive_calculation ( text ): time . sleep ( 1 ) def output_text (): textarea . value += text + \" \\n \" do_in_ui_thread ( output_text ) expensive_calculation ( 1 ) expensive_calculation ( 2 ) expensive_calculation ( 3 ) The textarea should contain: 1 2 3 Parameters: Name Type Description Default func typing . Callable fucntion to be called (without any arguments) required","title":"do_in_ui_thread()"},{"location":"gallery/material-editor/","text":"An editor GUI for the magnetic properties of materials. The NonLinearUI is implmented in an object-oriented way. Screenshots Non-Linear Material Linear Material Source from formify import * import json import numpy as np def save_material (): fn = tools . save_dialog ( \"Save Material\" ) if not fn : return with open ( fn , \"w+\" ) as f : json . dump ( material_form . value , f ) def load_current_material (): fn = tools . open_dialog ( \"Load Material\" ) if not fn : return with open ( fn ) as f : material_form . value = json . loads ( f . read ()) def print_material (): print ( json . dumps ( material_form . value , indent = 2 )) class NonLinearUI : def __init__ ( self ): self . plot = ControlMatplotlib () self . table = ControlTable ( label = \"Magnetization Curve\" , columns = [ \"H in A/m\" , \"B in T\" ], column_types = [ float , float ], variable_name = \"magnetization_curve\" , ) self . ui = Row ( self . table , self . plot , ) self . draw = tools . BackgroundMethod ( self . _draw , lazy = True ) self . table . change . subscribe ( self . draw ) def _draw ( self ): fig = self . plot . fig fig . clf () ax = fig . gca () B_H_data = np . array ( self . table . value ) ax . plot ( B_H_data [:, 0 ], B_H_data [:, 1 ]) ax . set_xlabel ( \"H in A/m\" ) ax . set_ylabel ( \"B in T\" ) ax . set_xscale ( \"log\" ) self . plot . draw () checkbox_linear = ControlCheckbox ( \"Linear B(H) characteristic\" , variable_name = \"is_linear\" ) # using ColSpaceBetween with a placeholder at the and makes sure the linear ui can expand just as the non-linear ui ui_linear = ColSpaceBetween ( ControlFloat ( \"Relative permeability \u03bcr\" , value = 1 , variable_name = \"mur\" ), Placeholder (), ) material_form = Form ( Segment ( h3 ( \"Material\" ), ControlText ( \"Name\" , variable_name = \"name\" ), ControlFloatMega ( \"Conductivity in MS/m\" , variable_name = \"conductivity\" ), ConditionalForm ({ True : ui_linear , False : NonLinearUI () . ui , }, condition_control = checkbox_linear , # \"__flatten__\" is a special variable name: # keys and values from are set in the parent level variable_name = \"__flatten__\" ), Row ( ControlButton ( \"Save Material...\" , save_material ), ControlButton ( \"Load Material...\" , load_current_material ), ControlButton ( \"Print Material\" , print_material ), ), )) materials_form = ListForm ( tools . maximize ( material_form ), variable_name = \"materials\" , display_name_callback = lambda material : material [ 'name' ], ) MainWindow ( materials_form , margin = 8 )","title":"Material Editor"},{"location":"gallery/material-editor/#screenshots","text":"Non-Linear Material Linear Material","title":"Screenshots"},{"location":"gallery/material-editor/#source","text":"from formify import * import json import numpy as np def save_material (): fn = tools . save_dialog ( \"Save Material\" ) if not fn : return with open ( fn , \"w+\" ) as f : json . dump ( material_form . value , f ) def load_current_material (): fn = tools . open_dialog ( \"Load Material\" ) if not fn : return with open ( fn ) as f : material_form . value = json . loads ( f . read ()) def print_material (): print ( json . dumps ( material_form . value , indent = 2 )) class NonLinearUI : def __init__ ( self ): self . plot = ControlMatplotlib () self . table = ControlTable ( label = \"Magnetization Curve\" , columns = [ \"H in A/m\" , \"B in T\" ], column_types = [ float , float ], variable_name = \"magnetization_curve\" , ) self . ui = Row ( self . table , self . plot , ) self . draw = tools . BackgroundMethod ( self . _draw , lazy = True ) self . table . change . subscribe ( self . draw ) def _draw ( self ): fig = self . plot . fig fig . clf () ax = fig . gca () B_H_data = np . array ( self . table . value ) ax . plot ( B_H_data [:, 0 ], B_H_data [:, 1 ]) ax . set_xlabel ( \"H in A/m\" ) ax . set_ylabel ( \"B in T\" ) ax . set_xscale ( \"log\" ) self . plot . draw () checkbox_linear = ControlCheckbox ( \"Linear B(H) characteristic\" , variable_name = \"is_linear\" ) # using ColSpaceBetween with a placeholder at the and makes sure the linear ui can expand just as the non-linear ui ui_linear = ColSpaceBetween ( ControlFloat ( \"Relative permeability \u03bcr\" , value = 1 , variable_name = \"mur\" ), Placeholder (), ) material_form = Form ( Segment ( h3 ( \"Material\" ), ControlText ( \"Name\" , variable_name = \"name\" ), ControlFloatMega ( \"Conductivity in MS/m\" , variable_name = \"conductivity\" ), ConditionalForm ({ True : ui_linear , False : NonLinearUI () . ui , }, condition_control = checkbox_linear , # \"__flatten__\" is a special variable name: # keys and values from are set in the parent level variable_name = \"__flatten__\" ), Row ( ControlButton ( \"Save Material...\" , save_material ), ControlButton ( \"Load Material...\" , load_current_material ), ControlButton ( \"Print Material\" , print_material ), ), )) materials_form = ListForm ( tools . maximize ( material_form ), variable_name = \"materials\" , display_name_callback = lambda material : material [ 'name' ], ) MainWindow ( materials_form , margin = 8 )","title":"Source"},{"location":"gallery/matplotlib/","text":"A matplolib figure embedded in a formify GUI. The UI changes based on the selected shape. A Circle only shows an input for the radius, while the rectangle shows controls for width, height and angle. The list containing the shapes can be reordered using drag and drop. Drawing in matplotlib happens in a background thread ( tools.BackgroundMethod ) to keep the UI responsive. Screenshot Source shapes_gui.py shapes.py from formify import * import copy # import shapes.py import shapes form = Form ( Col ( Row ( ControlFloat ( variable_name = \"x\" ), ControlFloat ( variable_name = \"y\" ), ), ControlText ( variable_name = \"color\" , value = \"red\" ), ConditionalForm ({ \"rectangle\" : Col ( ControlFloat ( variable_name = \"width\" ), ControlFloat ( variable_name = \"height\" ), ControlFloat ( \"Angle in \u00b0\" , variable_name = \"angle\" ), ), \"circle\" : Col ( ControlFloat ( variable_name = \"radius\" ), ), \"n_gon\" : Col ( ControlInt ( variable_name = \"corners\" ), ControlFloat ( variable_name = \"radius\" ), ), \"star\" : Col ( ControlInt ( variable_name = \"corners\" ), ControlFloat ( variable_name = \"inner_radius\" ), ControlFloat ( variable_name = \"outer_radius\" ), ), }, variable_name = \"__flatten__\" ), ) ) list_form = ListForm ( form , display_name_callback = lambda x : f ' { x [ \"type\" ] } ( { x [ \"color\" ] } )' , variable_name = \"list_form\" ) plot = ControlMatplotlib () def _draw (): # setup plot . fig . clear () ax = plot . fig . subplots () ax . set_aspect ( 'equal' ) # plotting for data in copy . deepcopy ( list_form . value ): func = getattr ( shapes , data . pop ( \"type\" )) func ( ax , ** data ) # show ax . plot () plot . draw () draw = tools . BackgroundMethod ( _draw , lazy = True ) list_form . change . subscribe ( draw ) tools . maximize ( list_form ) ui = Row ( SegmentLight ( h2 ( \"Shapes\" ), list_form , ), plot ) MainWindow ( ui , margin = 8 ) import matplotlib.pyplot as plt import numpy as np import cmath def rectangle ( ax , x , y , width , height , angle , color ): ax . add_patch ( plt . Rectangle (( x , y ), width , height , angle = angle , color = color ) ) def circle ( ax , x , y , radius , color ): ax . add_patch ( plt . Circle (( x , y ), radius , color = color ) ) def polygon ( ax , xs , ys , closed , color ): ax . add_patch ( plt . Polygon ( np . array ([ xs , ys ]) . T , closed = closed , color = color ) ) def star ( ax , x , y , corners , inner_radius , outer_radius , color ): if corners < 2 : return angles_outer = np . linspace ( 0 , 2 * np . pi , corners , endpoint = False ) angles_inner = angles_outer + 2 * np . pi / corners / 2 center = x + 1. j * y ps = [] for angle_inner , angle_outer in zip ( angles_inner , angles_outer ): ps . append ( cmath . rect ( outer_radius , angle_outer ) + center ) ps . append ( cmath . rect ( inner_radius , angle_inner ) + center ) ps = np . array ( ps ) polygon ( ax , ps . real , ps . imag , closed = True , color = color ) def n_gon ( ax , x , y , corners , radius , color ): if corners < 2 : return angles = np . linspace ( 0 , 2 * np . pi , corners , endpoint = False ) center = x + 1. j * y ps = [ cmath . rect ( radius , angle ) + center for angle in angles ] ps = np . array ( ps ) polygon ( ax , ps . real , ps . imag , closed = True , color = color ) if __name__ == \"__main__\" : # setup ax = plt . subplots ()[ 1 ] ax . set_aspect ( 'equal' ) # create patches rectangle ( ax , 1 , 1 , 1 , 2 , 0 , \"b\" ) circle ( ax , 2 , 3 , 1 , \"r\" ) star ( ax , 2 , 0 , 12 , 0.7 , 2 , \"k\" ) n_gon ( ax , 0 , 2 , 5 , 1 , \"yellow\" ) # plotting ax . plot () plt . show ()","title":"Matplotlib"},{"location":"gallery/matplotlib/#screenshot","text":"","title":"Screenshot"},{"location":"gallery/matplotlib/#source","text":"shapes_gui.py shapes.py from formify import * import copy # import shapes.py import shapes form = Form ( Col ( Row ( ControlFloat ( variable_name = \"x\" ), ControlFloat ( variable_name = \"y\" ), ), ControlText ( variable_name = \"color\" , value = \"red\" ), ConditionalForm ({ \"rectangle\" : Col ( ControlFloat ( variable_name = \"width\" ), ControlFloat ( variable_name = \"height\" ), ControlFloat ( \"Angle in \u00b0\" , variable_name = \"angle\" ), ), \"circle\" : Col ( ControlFloat ( variable_name = \"radius\" ), ), \"n_gon\" : Col ( ControlInt ( variable_name = \"corners\" ), ControlFloat ( variable_name = \"radius\" ), ), \"star\" : Col ( ControlInt ( variable_name = \"corners\" ), ControlFloat ( variable_name = \"inner_radius\" ), ControlFloat ( variable_name = \"outer_radius\" ), ), }, variable_name = \"__flatten__\" ), ) ) list_form = ListForm ( form , display_name_callback = lambda x : f ' { x [ \"type\" ] } ( { x [ \"color\" ] } )' , variable_name = \"list_form\" ) plot = ControlMatplotlib () def _draw (): # setup plot . fig . clear () ax = plot . fig . subplots () ax . set_aspect ( 'equal' ) # plotting for data in copy . deepcopy ( list_form . value ): func = getattr ( shapes , data . pop ( \"type\" )) func ( ax , ** data ) # show ax . plot () plot . draw () draw = tools . BackgroundMethod ( _draw , lazy = True ) list_form . change . subscribe ( draw ) tools . maximize ( list_form ) ui = Row ( SegmentLight ( h2 ( \"Shapes\" ), list_form , ), plot ) MainWindow ( ui , margin = 8 ) import matplotlib.pyplot as plt import numpy as np import cmath def rectangle ( ax , x , y , width , height , angle , color ): ax . add_patch ( plt . Rectangle (( x , y ), width , height , angle = angle , color = color ) ) def circle ( ax , x , y , radius , color ): ax . add_patch ( plt . Circle (( x , y ), radius , color = color ) ) def polygon ( ax , xs , ys , closed , color ): ax . add_patch ( plt . Polygon ( np . array ([ xs , ys ]) . T , closed = closed , color = color ) ) def star ( ax , x , y , corners , inner_radius , outer_radius , color ): if corners < 2 : return angles_outer = np . linspace ( 0 , 2 * np . pi , corners , endpoint = False ) angles_inner = angles_outer + 2 * np . pi / corners / 2 center = x + 1. j * y ps = [] for angle_inner , angle_outer in zip ( angles_inner , angles_outer ): ps . append ( cmath . rect ( outer_radius , angle_outer ) + center ) ps . append ( cmath . rect ( inner_radius , angle_inner ) + center ) ps = np . array ( ps ) polygon ( ax , ps . real , ps . imag , closed = True , color = color ) def n_gon ( ax , x , y , corners , radius , color ): if corners < 2 : return angles = np . linspace ( 0 , 2 * np . pi , corners , endpoint = False ) center = x + 1. j * y ps = [ cmath . rect ( radius , angle ) + center for angle in angles ] ps = np . array ( ps ) polygon ( ax , ps . real , ps . imag , closed = True , color = color ) if __name__ == \"__main__\" : # setup ax = plt . subplots ()[ 1 ] ax . set_aspect ( 'equal' ) # create patches rectangle ( ax , 1 , 1 , 1 , 2 , 0 , \"b\" ) circle ( ax , 2 , 3 , 1 , \"r\" ) star ( ax , 2 , 0 , 12 , 0.7 , 2 , \"k\" ) n_gon ( ax , 0 , 2 , 5 , 1 , \"yellow\" ) # plotting ax . plot () plt . show ()","title":"Source"},{"location":"gallery/people/","text":"A basic editor for personal data. Screenshots List Form Table Data Model The data model between the ListForm and ControlTable implementation is different. The ListForm workes with a list of dicts, whereas the ControlTable uses a 2D list. List Form Table { \"people\" : [ { \"first_name\" : \"Nicola \" , \"surname\" : \"Hailee\" , \"phone\" : \"+1 544 554 335\" , \"age\" : 32 , \"role\" : \"Admin\" }, { \"first_name\" : \"James \" , \"surname\" : \"Munir\" , \"phone\" : \"+1 142 512 852\" , \"age\" : 22 , \"role\" : \"User\" } ] } { \"people_table\" : [ [ \"Nicola \" , \"Hailee\" , \"+1 544 554 335\" , 32 , \"Admin\" ], [ \"James \" , \"Munir\" , \"+1 142 512 852\" , 22 , \"User\" ] ] } Source from formify import * # Option 1: A list form with a person form person_form = Form ( Col ( ControlText ( \"First Name\" , variable_name = \"first_name\" ), ControlText ( \"Surname\" , variable_name = \"surname\" ), ControlText ( \"Phone Number\" , variable_name = \"phone\" ), ControlInt ( \"Age\" , variable_name = \"age\" ), ControlSelect ( \"Role\" , items = [ \"User\" , \"Admin\" ], variable_name = \"role\" , value = \"User\" ) )) ui_list = ListForm ( person_form , variable_name = \"people\" , display_name_callback = lambda person : f \" { person [ 'first_name' ] } { person [ 'surname' ] } - { person [ 'role' ] } \" ) # Option 2: A table ui_table = ControlTable ( label = \"\" , columns = [ \"First Name\" , \"Surname\" , \"Phone Number\" , \"Age\" , \"Role\" ], column_types = [ str , str , str , int , ( \"User\" , \"Admin\" )], variable_name = \"people_table\" ) ui = SidebarContentView ({ \"ListForm\" : ui_list , \"Table\" : ui_table , }) MainWindow ( ui )","title":"People Editor"},{"location":"gallery/people/#screenshots","text":"List Form Table","title":"Screenshots"},{"location":"gallery/people/#data-model","text":"The data model between the ListForm and ControlTable implementation is different. The ListForm workes with a list of dicts, whereas the ControlTable uses a 2D list. List Form Table { \"people\" : [ { \"first_name\" : \"Nicola \" , \"surname\" : \"Hailee\" , \"phone\" : \"+1 544 554 335\" , \"age\" : 32 , \"role\" : \"Admin\" }, { \"first_name\" : \"James \" , \"surname\" : \"Munir\" , \"phone\" : \"+1 142 512 852\" , \"age\" : 22 , \"role\" : \"User\" } ] } { \"people_table\" : [ [ \"Nicola \" , \"Hailee\" , \"+1 544 554 335\" , 32 , \"Admin\" ], [ \"James \" , \"Munir\" , \"+1 142 512 852\" , 22 , \"User\" ] ] }","title":"Data Model"},{"location":"gallery/people/#source","text":"from formify import * # Option 1: A list form with a person form person_form = Form ( Col ( ControlText ( \"First Name\" , variable_name = \"first_name\" ), ControlText ( \"Surname\" , variable_name = \"surname\" ), ControlText ( \"Phone Number\" , variable_name = \"phone\" ), ControlInt ( \"Age\" , variable_name = \"age\" ), ControlSelect ( \"Role\" , items = [ \"User\" , \"Admin\" ], variable_name = \"role\" , value = \"User\" ) )) ui_list = ListForm ( person_form , variable_name = \"people\" , display_name_callback = lambda person : f \" { person [ 'first_name' ] } { person [ 'surname' ] } - { person [ 'role' ] } \" ) # Option 2: A table ui_table = ControlTable ( label = \"\" , columns = [ \"First Name\" , \"Surname\" , \"Phone Number\" , \"Age\" , \"Role\" ], column_types = [ str , str , str , int , ( \"User\" , \"Admin\" )], variable_name = \"people_table\" ) ui = SidebarContentView ({ \"ListForm\" : ui_list , \"Table\" : ui_table , }) MainWindow ( ui )","title":"Source"},{"location":"gallery/pyvista-solids/","text":"A Pyvista plot embedded in a formify GUI. Shapes are added to the Pyvista scene using the UI. Screenshot Source To run this example you need to install pyvista first: pip install pyvista && pip install pyvistaqt from formify import * import pyvista as pv plot = ControlPyvista () plot . plotter . view_vector (( 5.0 , 2 , 3 )) plot . plotter . add_floor ( '-z' , lighting = True , color = 'white' , pad = 10 ) plot . plotter . enable_shadows () def add_solid (): data = form . value solid = pv . PlatonicSolid ( data [ \"kind\" ], radius = data [ \"r\" ], center = ( data [ \"x\" ], data [ \"y\" ], data [ \"z\" ]) ) plot . plotter . add_mesh ( solid , color = data [ \"color\" ], smooth_shading = True , specular = data [ \"specularity\" ], specular_power = 10 ) form = Form ( Row ( SegmentLight ( ControlSelect ( \"Kind\" , variable_name = \"kind\" , items = [ 'tetrahedron' , 'cube' , 'octahedron' , 'dodecahedron' , 'icosahedron' , ]), ControlSlider ( \"Radius\" , variable_name = \"r\" , value = 0.4 , minimum = 0.1 , maximum = 4 ), ControlSlider ( \"X\" , variable_name = \"x\" , value = 0 , minimum =- 5 , maximum = 5 ), ControlSlider ( \"Y\" , variable_name = \"y\" , value = 0 , minimum =- 5 , maximum = 5 ), ControlSlider ( \"Z\" , variable_name = \"z\" , value = 0 , minimum = 0 , maximum = 5 ), ControlSlider ( \"Specularity\" , variable_name = \"specularity\" , value = 0 , minimum = 0 , maximum = 1 ), ControlText ( \"Color\" , variable_name = \"color\" , value = \"silver\" ), ControlButton ( \"Add Solid\" , add_solid ), maximum_width = 200 , ), plot )) MainWindow ( form , margin = 8 )","title":"Pyvista Solids"},{"location":"gallery/pyvista-solids/#screenshot","text":"","title":"Screenshot"},{"location":"gallery/pyvista-solids/#source","text":"To run this example you need to install pyvista first: pip install pyvista && pip install pyvistaqt from formify import * import pyvista as pv plot = ControlPyvista () plot . plotter . view_vector (( 5.0 , 2 , 3 )) plot . plotter . add_floor ( '-z' , lighting = True , color = 'white' , pad = 10 ) plot . plotter . enable_shadows () def add_solid (): data = form . value solid = pv . PlatonicSolid ( data [ \"kind\" ], radius = data [ \"r\" ], center = ( data [ \"x\" ], data [ \"y\" ], data [ \"z\" ]) ) plot . plotter . add_mesh ( solid , color = data [ \"color\" ], smooth_shading = True , specular = data [ \"specularity\" ], specular_power = 10 ) form = Form ( Row ( SegmentLight ( ControlSelect ( \"Kind\" , variable_name = \"kind\" , items = [ 'tetrahedron' , 'cube' , 'octahedron' , 'dodecahedron' , 'icosahedron' , ]), ControlSlider ( \"Radius\" , variable_name = \"r\" , value = 0.4 , minimum = 0.1 , maximum = 4 ), ControlSlider ( \"X\" , variable_name = \"x\" , value = 0 , minimum =- 5 , maximum = 5 ), ControlSlider ( \"Y\" , variable_name = \"y\" , value = 0 , minimum =- 5 , maximum = 5 ), ControlSlider ( \"Z\" , variable_name = \"z\" , value = 0 , minimum = 0 , maximum = 5 ), ControlSlider ( \"Specularity\" , variable_name = \"specularity\" , value = 0 , minimum = 0 , maximum = 1 ), ControlText ( \"Color\" , variable_name = \"color\" , value = \"silver\" ), ControlButton ( \"Add Solid\" , add_solid ), maximum_width = 200 , ), plot )) MainWindow ( form , margin = 8 )","title":"Source"},{"location":"gallery/pyvista-wave/","text":"A Pyvista plot embedded in a formify GUI. The plot can be manipulated and animated using the controls on the left. Video Screenshot Source To run this example you need to install pyvista first: pip install pyvista && pip install pyvistaqt from formify import * import pyvista as pv import numpy as np from time import sleep plot = ControlPyvista () plot . plotter . set_background ( \"white\" ) x = np . arange ( - 10 , 10 , 0.2 ) y = np . arange ( - 10 , 10 , 0.2 ) x , y = np . meshgrid ( x , y ) r = np . sqrt ( x ** 2 + y ** 2 ) z = np . sin ( r ) # Create and structured surface grid = pv . StructuredGrid ( x , y , z ) # Create a plotter object and set the scalars to the Z height mesh = plot . plotter . add_mesh ( grid , scalars = z . ravel (), lighting = False , show_edges = True , scalar_bar_args = { \"title\" : \"Height\" , \"color\" : \"black\" }, clim = [ - 1 , 1 ], ) pts = grid . points . copy () def update_plot (): data = form . value z = data [ \"amplitude\" ] * np . sin ( data [ \"frequency\" ] * r + data [ \"phase\" ]) pts [:, - 1 ] = z . ravel () plot . plotter . update_coordinates ( pts , render = False ) plot . plotter . update_scalars ( z . ravel (), render = True ) check_animate = ControlCheckbox ( \"Animate\" , variable_name = \"animate\" ) slider_phase = ControlSlider ( \"Phase\" , variable_name = \"phase\" , value = 0 , minimum = 0 , maximum = 2 * np . pi , ticks = 10000 ) form = Form ( Row ( SegmentLight ( ControlSlider ( \"Amplitude\" , variable_name = \"amplitude\" , value = 1 , minimum =- 5 , maximum = 5 , ticks = 10000 ), ControlSlider ( \"Frequency\" , variable_name = \"frequency\" , value = 1 , minimum = 0 , maximum = 5 , ticks = 10000 ), slider_phase , check_animate , maximum_width = 200 , ), plot )) form . change . subscribe ( update_plot ) @tools . BackgroundMethod def start_animation (): while True : if check_animate . value : slider_phase . value = ( slider_phase . value + 0.1 ) % ( 2 * np . pi ) sleep ( 1 / 60 ) start_animation () MainWindow ( form , margin = 8 , width = 800 , height = 550 )","title":"Pyvista Wave"},{"location":"gallery/pyvista-wave/#source","text":"To run this example you need to install pyvista first: pip install pyvista && pip install pyvistaqt from formify import * import pyvista as pv import numpy as np from time import sleep plot = ControlPyvista () plot . plotter . set_background ( \"white\" ) x = np . arange ( - 10 , 10 , 0.2 ) y = np . arange ( - 10 , 10 , 0.2 ) x , y = np . meshgrid ( x , y ) r = np . sqrt ( x ** 2 + y ** 2 ) z = np . sin ( r ) # Create and structured surface grid = pv . StructuredGrid ( x , y , z ) # Create a plotter object and set the scalars to the Z height mesh = plot . plotter . add_mesh ( grid , scalars = z . ravel (), lighting = False , show_edges = True , scalar_bar_args = { \"title\" : \"Height\" , \"color\" : \"black\" }, clim = [ - 1 , 1 ], ) pts = grid . points . copy () def update_plot (): data = form . value z = data [ \"amplitude\" ] * np . sin ( data [ \"frequency\" ] * r + data [ \"phase\" ]) pts [:, - 1 ] = z . ravel () plot . plotter . update_coordinates ( pts , render = False ) plot . plotter . update_scalars ( z . ravel (), render = True ) check_animate = ControlCheckbox ( \"Animate\" , variable_name = \"animate\" ) slider_phase = ControlSlider ( \"Phase\" , variable_name = \"phase\" , value = 0 , minimum = 0 , maximum = 2 * np . pi , ticks = 10000 ) form = Form ( Row ( SegmentLight ( ControlSlider ( \"Amplitude\" , variable_name = \"amplitude\" , value = 1 , minimum =- 5 , maximum = 5 , ticks = 10000 ), ControlSlider ( \"Frequency\" , variable_name = \"frequency\" , value = 1 , minimum = 0 , maximum = 5 , ticks = 10000 ), slider_phase , check_animate , maximum_width = 200 , ), plot )) form . change . subscribe ( update_plot ) @tools . BackgroundMethod def start_animation (): while True : if check_animate . value : slider_phase . value = ( slider_phase . value + 0.1 ) % ( 2 * np . pi ) sleep ( 1 / 60 ) start_animation () MainWindow ( form , margin = 8 , width = 800 , height = 550 )","title":"Source"}]}